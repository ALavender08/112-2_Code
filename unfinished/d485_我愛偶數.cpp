#include <bits/stdc++.h>
using namespace std;
int main()
{
    int i1,i2;
    cin>>i1>>i2;
    int out=(int)(((float)(i2-i1)/2)+0.5)+abs((int)((float)((i1%2)+(i2%2))/2+0.5)-1);
    cout<<out;
    return 0;

    /*
    先備知識:
    1. 如果資料型態為 int ，C++除法時會無條件捨位
    2. 一奇一偶相加或相減都會得到奇數，兩個奇數或兩個偶數相加或相減都會得到偶數

    解題思路:
    1. 依序輸入兩數
    2. 將 out 以「+」分割成前半段及後半段程式說明:

        。前半段語法說明:
        兩數相減後除2再加0.5

        。前半段這麼寫的原因:
        每兩數必有一偶數，因此若是兩數相減== a(奇) 或 a+1(偶) ，兩數所涵蓋的範圍便是 a+1(偶) ~ a+2(奇)，
        所以此兩數之間有 (a+1)/2 個偶數

        但是!!!因為題目上限是 0~2147483647，找範圍時不能用+1的方法，不然會爆掉( 2147483648=2的31次方為上限，別問我怎麼知道的(¬‿¬) )，
        因此我的程式改成:

        (a+1)/2= a/2 + 1/2 = 兩數相減/2 + 0.5
        兩數相減/2 時要用浮點數表示，否則C++會給你無條件捨位
        最後也要記得強轉整數，問你共有幾個整數不會有小數點個



        。後半段語法說明:
        兩數除2的餘數相加，再除二，再加0.5，取整數後再-1，最後再取絕對值

        。後半段這麼寫的原因:
        兩數有三種可能，兩個都奇數，兩個都偶數，一奇一偶，
        因此我們要寫能篩選出兩者都偶數的條件，因為前半段的程式只能篩出頭尾其中一個偶數及兩數之間的偶數

        我的想法是用討論法(?):
        1. 若兩數皆為奇數，則相減為偶數，答案應要得到 (兩數相減(偶)+1)/2=兩數相減/2 個偶數(記得無條件捨位)(前半段程式已算出)
           執行後半程式結果:
           兩數取除2的餘數皆為1，(1+1)/2=1.0，1.0+0.5=1.5，強轉整數=1，1-1=0，
           原本找出的偶數+0=不變 (頭尾都是奇數，不需要因頭尾都偶數而+1)

        2. 若兩數一奇一偶，則相減為奇數，答案應要得到 (兩數相減(奇)+1)/2 個偶數(前半段程式已算出)
           執行後半段程式結果:
           兩數取除2的餘數為 1 和 0，相加/2 = (1+0)/2 = 0.5 ，0.5+0.5=1.0 ，強轉整數=1，1-1=0，
           前半段程式+0=不變 (原本涵蓋的範圍/2 已經是他的偶數數量)

        3. 若兩數皆為偶數，

    */
}
